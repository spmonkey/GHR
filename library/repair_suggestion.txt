Host头攻击漏洞:web应用程序应该使用SERVER_NAME而不是host header。\n在Apache和Nginx里可以通过设置一个虚拟机来记录所有的非法host header。在Nginx里还可以通过指定一个SERVER_NAME名单，Apache也可以通过指定一个SERVER_NAME名单并开启UseCanonicalName选项。
JavaScript框架库漏洞:1.升级最新的JavaScript框架库。\n参考链接如下：http://blog.jquery.com/
任意命令执行漏洞:1、严格过滤用户输入的数据，禁止执行非预期系统命令;\n2、减少或不使用代码或命令执行函数;\n3、客户端提交的变量在放入函数前进行检测;\n4、减少或不使用危险函数。
服务器端请求伪造漏洞:1、禁用不需要的协议，只允许HTTP和HTTPS请求，可以防止类似于file://, gopher://, ftp:// 等引起的问题。\n2、白名单的方式限制访问的目标地址，禁止对内网发起请求；\n3、过滤或屏蔽请求返回的详细信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。\n4、验证请求的文件格式\n5、禁止跳转\n6、限制请求的端口为http常用的端口，比如 80、443、8080、8000等\n7、统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。
弱口令漏洞:建议强制性用户设置密码长度至少为8位，并且包含大小字母、数字、符号等。
开启了 OPTIONS 方法:修改配置文件禁用options方法。\n如：IIS 配置》请求筛选》http谓词》禁止OPTIONS 》重启IIS后完成。
XML外部实体注入漏洞:1、使用开发语言提供的禁用外部实体的方法：\n（1）PHP：  libxml_disable_entity_loader(true);\n（2）JAVA： DocumentBuilderFactor dbf=DocumentBuilderFactor.newlnstance();dbf.setExpandEntityReferences(false);\n（3）Python：from lxml import etree\nxmlData=etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))\n2、过滤用户提交的XML数据，过滤关键字：<\!DOCTYPE和<\!ENTITY，或者SYSTEM和PUBLIC。\n3、不允许XML中含有自己定义的DTD。
远程代码执行漏洞:1、严格过滤用户输入的数据，禁止执行非预期系统命令;\n2、减少或不使用代码或命令执行函数;\n3、客户端提交的变量在放入函数前进行检测;\n4、减少或不使用危险函数。
敏感信息泄露漏洞:1、不在网站目录下存放网站备份文件或敏感信息的文件。\n2、如需存放该类文件，请将文件名命名为难以猜解的无规则字符串。
SQL注入漏洞:代码层最佳防御sql漏洞方案：使用预编译sql语句查询和绑定变量：\n1、使用预编译语句，使用PDO需要注意不要将变量直接拼接到PDO语句中。所有的查询语句都使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中。当前几乎所有的数据库系统都提供了参数化SQL语句执行接口，使用此接口可以非常有效的防止SQL注入攻击。\n2、对进入数据库的特殊字符（’”<>&*;等）进行转义处理，或编码转换。\n3、确认每种数据的类型，比如数字型的数据就必须是数字，数据库中的存储字段必须对应为int型。\n4、数据长度应该严格规定，能在一定程度上防止比较长的SQL注入语句无法正确执行。\n5、网站每个数据层的编码统一，建议全部使用UTF-8编码，上下层编码不一致有可能导致一些过滤模型被绕过。\n6、严格限制网站用户的数据库的操作权限，给此用户提供仅仅能够满足其工作的权限，从而最大限度的减少注入攻击对数据库的危害。\n7、避免网站显示SQL错误信息，比如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断。\n8、过滤危险字符，例如：采用正则表达式匹配union、sleep、and、select、load_file等关键字，如果匹配到则终止运行。
任意文件读取漏洞:1、过滤../等敏感字符，使用户在url中不能回溯上级目录；\n2、文件下载时判断输入的路径，最好的方法是文件应该在数据库中进行一一对应，避免通过输入绝对路径来获取文件；\n3、php.ini配置open_basedir限定文件访问范围。
任意文件上传漏洞:1、对上传文件类型进行验证，除在前端验证外在后端依然要做验证，后端可以进行扩展名检测，重命名文件，MIME类型检测以及限制上传文件的大小等限制来防御，或是将上传的文件其他文件存储服务器中。\n2、严格限制和校验上传的文件，禁止上传恶意代码的文件。同时限制相关上传文件目录的执行权限，防止木马执行。\n3、对上传文件格式进行严格校验，防止上传恶意脚本文件；\n4、严格限制上传的文件路径。\n5、文件扩展名服务端白名单校验。\n6、文件内容服务端校验。\n7、上传文件重命名。\n8、隐藏上传文件路径。
任意用户注册漏洞:1、验证邮箱/手机号：确保在注册过程中，所有的邮箱和手机号都经过严格的验证，包括格式验证和真实性验证。可以采用发送验证邮件或短信验证码的方式，确保用户身份的真实性。\n2、安全验证邮箱/手机号：除了验证邮箱和手机号的格式外，还应该确保验证过程中的安全性，防止信息泄露或被恶意利用。\n3、防止批量注册：通过限制同一IP地址或同一设备在一定时间内的注册数量，可以有效防止恶意批量注册行为。\n4、个人信息安全：在用户注册时，对敏感信息进行加密处理，并确保存储安全，防止个人信息被伪造或滥用。\n5、前端验证与后端验证相结合：不仅要在前端进行数据验证，还要在后端进行必要的验证，以防止攻击者绕过前端验证直接向服务器发送请求。\n6、用户名唯一性检查：在用户注册时，对用户名进行检查，确保每个用户名的唯一性，避免用户名覆盖的问题。\n7、密码复杂度要求：要求用户设置复杂度较高的密码，并定期更换密码，增加账户安全性。\n8、验证码使用：在关键操作如登录、注册、密码重置等环节使用验证码，防止自动化工具的攻击。\n9、登录检测机制：建立安全的登录检测机制，确保登录过程的安全性，防止万能密码等攻击手段。\n10、账号重置安全：在账号重置流程中，确保安全措施到位，如通过多重验证来确认用户身份，防止未经授权的账号重置。
登录绕过漏洞:1、对用户登录接⼝进行多重身份验证，如token令牌，短信验证码，多个参数结合认证等方式。\n2、严格校验客户端提交的用户登录请求，对应请求的用户身份和当前登录的用户身份进行服务端与客户端双向校验，判断是否有权登录用户。
任意文件下载漏洞:对下载路径进行过滤，如下载前对传入的参数进行过滤，并且对下载文件类型进行检查，是否是允许下载的类型，另外禁止使用回溯符…/！
任意密码重置漏洞:1、一次填写检查信息(原始密码、新密码等)后，递交修改密码请求。\n2、对客户端递交的修改密码请求，对应请求的用户身份和当前登录的用户身份进行验证，判断是否有权修改用户的密码，也判断原始密码是否正确。\n3、不受验证信息的手机、邮箱等信息不应全部明确传达给客户，不应屏蔽手机、邮箱等信息，不应返回客户端。\n4、验证原始密码时，限制输入原始密码的错误次数，防止攻击者暴力破解原始密码。\n5、重置密码链接的重要信息应随机化，无法预测(例如token机制)，禁止将重要信息返回客户端。
未授权访问漏洞:1、页面进行严格的访问权限的控制以及对访问角色进行权限检查。\n2、可以使用session对用户的身份进行判断和控制
目录遍历漏洞:1、严格检查变量是否已经初始化。\n2、对所有输入提交可能包含的文件地址，包括服务器本地文件及远程文件，进行严格的检查，参数中不允许出现./和../等目录跳转符。\n3、严格检查文件包含函数中的参数是否外界可控。
反序列化漏洞:1、类的白名单校验机制：实际上原理很简单，就是对所有传入的反序列化对象，在反序列化过程开始前，对类型名称做一个检查，不符合白名单的类不进行反序列化操作。很显然，这个白名单肯定是不存在Runtime的。\n2、禁止JVM执行外部命令Runtime.exec，这个措施可以通过扩展 SecurityManager 可以实现。
跨站脚本注入攻击漏洞:xss漏洞本质上是一种html注入，也就是将html代码注入到网页中。那么其防御的根本就是在将用户提交的代码显示到页面上时做好一系列的过滤与转义\n（1）过滤输入的数据，对例如：" ' "、" " "、" < "、" > "、" on* "、script、iframe等危险字符进行严格的检查。这里的输入不仅仅是用户可以直接交互的输入接口，也包括HTTP请求中的Cookie中的变量，HTTP请求头部中的变量等。\n（2）不仅验证数据的类型，还要验证其格式、长度、范围和内容。\n（3）不仅在客户端做数据的验证与过滤，关键的过滤步骤在服务端进行。\n（4）对输出到页面的数据进行相应的编码转换，如HTML实体编码、JS编码等。对输出的数据也要检查，数据库里的值有可能会在一个大网站的多处都有输出，即使在输入做了编码等操作，在各处的输出点时也要进行检查。
跨站式追踪攻击漏洞:Web 服务器限制 Trace、Track 方法的请求。
CORS跨域资源共享漏洞:1、Access-Control-Allow-Origin中指定的来源只能是受信任的站点，避免使用Access-Control-Allow-Origin: *，避免使用Access-Control-Allow-Origin: null，否则攻击者可以伪造来源请求实现跨域资源窃取。\n2、严格校验“Origin”值，校验的正则表达式一定要编写完善，避免出现绕过的情况。\n3、减少“Access-Control-Allow-Methods”所允许的请求方法。\n4、除了正确配置CORS之外，Web服务器还应继续对敏感数据进行保护，例如身份验证和会话管理等。